<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>èµ¤åˆƒæ˜éœ„é™ˆ æˆ˜æœ¯æ¨¡æ‹Ÿç»ˆç«¯ (v5.5 BOSSæ”¯æŒç‰ˆ)</title>
    <style>
      :root {
        --bg-color: #121212;
        --panel-bg: #1c1c1c;
        --btn-bg: #2b2b2b;
        --btn-border: #3d3d3d;
        --accent-red: #ff3333;
        --accent-gold: #ffaa00;
        --text-main: #ffffff;
        --text-sub: #888888;
        --item-hover: #333;
        --item-active: #442222;
      }
      body {
        margin: 0;
        background-color: var(--bg-color);
        color: var(--text-main);
        font-family: "Segoe UI", Roboto, sans-serif;
        display: flex;
        height: 100vh;
        overflow: hidden;
      }
      #assets {
        position: absolute;
        top: -9999px;
        left: -9999px;
        width: 1px;
        height: 1px;
        opacity: 0;
        overflow: hidden;
        pointer-events: none;
        z-index: -1;
      }
      #canvas-wrapper {
        flex: 1;
        position: relative;
        background-image: radial-gradient(circle at center, #222 0%, #111 100%);
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
        overscroll-behavior: none;
        touch-action: none;
      }
      canvas {
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        background: rgba(30, 30, 30, 0.3);
        border: 1px solid #333;
      }
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        z-index: 100;
        backdrop-filter: blur(5px);
      }
      .loader {
        width: 40px;
        height: 40px;
        border: 3px solid transparent;
        border-top-color: var(--accent-red);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      #sidebar {
        width: 300px;
        background-color: var(--panel-bg);
        border-left: 1px solid #333;
        display: flex;
        flex-direction: column;
        padding: 25px;
        box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
        z-index: 10;
        overflow-y: hidden;
      }

      @media (max-width: 768px) {
        body {
          flex-direction: column;
        }
        #canvas-wrapper {
          flex: none;
          height: 55vh;
          border-bottom: 1px solid #333;
        }
        #sidebar {
          width: 100%;
          flex: 1;
          border-left: none;
          padding: 15px;
          box-sizing: border-box;
          flex-direction: row;
          flex-wrap: wrap;
          align-content: flex-start;
          gap: 10px;
          overflow-y: auto;
        }
        .section {
          width: 48%;
          margin-bottom: 0;
        }
        .section-header {
          display: none;
        }
        #combo-panel {
          top: 10px;
          right: 10px;
          transform: scale(0.8);
        }
        #result-section {
          width: 100% !important;
          margin-top: 10px;
          max-height: none !important;
        }
      }

      .section-header {
        font-size: 14px;
        color: var(--text-sub);
        margin-bottom: 10px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-bottom: 1px solid #333;
        padding-bottom: 5px;
        font-weight: bold;
      }
      .section {
        margin-bottom: 25px;
      }
      button {
        background: var(--btn-bg);
        border: 1px solid var(--btn-border);
        color: var(--text-main);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.15s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 10px 0;
        position: relative;
        user-select: none;
        touch-action: manipulation;
      }
      button:hover {
        background: #333;
        border-color: #555;
      }
      button:active {
        transform: translateY(1px);
      }
      .btn-label {
        font-size: 13px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .btn-key {
        font-size: 10px;
        color: #666;
        margin-top: 4px;
        font-weight: bold;
        background: rgba(0, 0, 0, 0.2);
        padding: 1px 6px;
        border-radius: 4px;
      }
      button.active {
        border-color: var(--accent-red);
        background: rgba(255, 51, 51, 0.08);
        box-shadow: inset 0 0 0 1px var(--accent-red);
      }
      button.active .btn-label {
        color: #ffcccc;
      }
      button.active .btn-key {
        color: var(--accent-red);
        background: rgba(255, 51, 51, 0.1);
      }

      .row-2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 8px;
      }
      .row-1 {
        width: 100%;
        margin-bottom: 8px;
      }
      #btn-start {
        background: linear-gradient(135deg, var(--accent-red), #cc0000);
        border: none;
        color: white;
        padding: 15px 0;
        box-shadow: 0 4px 15px rgba(255, 51, 51, 0.3);
      }
      #btn-start:hover {
        background: linear-gradient(135deg, #ff5555, #dd0000);
        transform: translateY(-1px);
        box-shadow: 0 6px 20px rgba(255, 51, 51, 0.4);
      }
      #status-text {
        color: var(--accent-gold);
        font-weight: bold;
        margin-left: 4px;
      }

      #result-section {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
        margin-bottom: 0;
      }
      #result-list {
        flex: 1;
        overflow-y: auto;
        border: 1px solid #333;
        border-radius: 4px;
        background: rgba(0, 0, 0, 0.2);
        padding: 5px;
      }
      .res-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 10px;
        margin-bottom: 4px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        border-left: 3px solid transparent;
      }
      .res-item:hover {
        background: var(--item-hover);
      }
      .res-item.active {
        background: rgba(255, 51, 51, 0.1);
        border-left-color: var(--accent-red);
      }
      .res-score {
        font-size: 16px;
        font-weight: bold;
        color: var(--accent-gold);
        font-family: "Impact", sans-serif;
        letter-spacing: 1px;
      }
      .res-info {
        font-size: 11px;
        color: #888;
        text-align: right;
        line-height: 1.3;
      }
      .res-tag {
        display: inline-block;
        padding: 1px 4px;
        border-radius: 3px;
        font-size: 10px;
        margin-left: 5px;
        font-weight: bold;
      }
      .tag-static {
        background: #334455;
        color: #ccddff;
      }
      .tag-dynamic {
        background: #553333;
        color: #ffcccc;
      }

      ::-webkit-scrollbar {
        width: 6px;
      }
      ::-webkit-scrollbar-track {
        background: #1a1a1a;
      }
      ::-webkit-scrollbar-thumb {
        background: #444;
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #666;
      }

      #save-area-wrapper {
        margin-top: 15px;
        border-top: 1px solid #333;
        padding-top: 10px;
        max-height: 120px;
        display: flex;
        flex-direction: column;
      }
      #save-area {
        overflow-y: auto;
        flex: 1;
      }
      .save-item {
        font-size: 12px;
        padding: 6px;
        border-bottom: 1px solid #2a2a2a;
        color: #888;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
      }
      .save-item:hover {
        color: #fff;
        background: #222;
      }
      .del-save {
        color: #552222;
        padding: 0 5px;
      }
      .del-save:hover {
        color: #ff4444;
      }

      #combo-panel {
        position: absolute;
        top: 30px;
        right: 20px;
        text-align: right;
        pointer-events: none;
        opacity: 0;
        transform: translateY(-20px);
        transition:
          opacity 0.3s,
          transform 0.3s;
        z-index: 50;
        white-space: nowrap;
      }
      #combo-panel.active {
        opacity: 1;
        transform: translateY(0);
      }
      .combo-label {
        font-size: 14px;
        color: var(--accent-gold);
        letter-spacing: 4px;
        font-weight: 800;
        margin-bottom: -5px;
        text-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
      }
      #combo-count {
        font-size: 72px;
        font-weight: 900;
        font-style: italic;
        font-family: "Impact", "Arial Black", sans-serif;
        background: linear-gradient(180deg, #fff 20%, #ffaa00 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        filter: drop-shadow(0 0 15px rgba(255, 60, 0, 0.6));
        line-height: 1;
        transform-origin: center center;
        padding-top: 5px;
        padding-right: 30px;
        margin-right: -22px;
      }
      .pulse-anim {
        animation: comboPulse 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }
      @keyframes comboPulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.4);
        }
        100% {
          transform: scale(1);
        }
      }
    </style>
  </head>
  <body>
    <div id="assets">
      <video
        id="chenVideo"
        src="chen.webm"
        loop
        autoplay
        muted
        playsinline
      ></video>
      <img id="enemyImg" src="enemy.png" alt="enemy" />
    </div>

    <div id="canvas-wrapper">
      <canvas id="gameCanvas"></canvas>
      <div id="combo-panel">
        <div class="combo-label">HITS</div>
        <div id="combo-count">0</div>
      </div>
      <div id="overlay">
        <div class="loader"></div>
        <div style="margin-top: 15px; color: #ddd; font-size: 12px">
          å…¨å›¾ç©·ä¸¾æ¼”ç®—ä¸­...
        </div>
      </div>
    </div>

    <div id="sidebar">
      <div class="section">
        <div class="section-header">åœ°å›¾ç¼–è¾‘ TOOLS</div>
        <div class="row-2">
          <button id="btn-wall" onclick="setTool('wall')">
            <span class="btn-label">ğŸ§± æ”¾ç½®éšœç¢</span
            ><span class="btn-key">W</span>
          </button>
          <button id="btn-ban" onclick="setTool('ban')">
            <span class="btn-label" style="color: #aaa">ğŸš« ç¦æ­¢éƒ¨ç½²</span
            ><span class="btn-key">X</span>
          </button>
        </div>
        <div class="row-2">
          <button id="btn-path" onclick="setTool('path')">
            <span class="btn-label" style="color: #ff8888">ğŸ¯ æ•Œäººè·¯å¾„</span
            ><span class="btn-key">F</span>
          </button>
          <button id="btn-boss" onclick="setTool('boss')">
            <span class="btn-label" style="color: #aa55aa">ğŸ‘¾ BOSSåˆ¤å®š</span
            ><span class="btn-key">B</span>
          </button>
        </div>
        <button
          onclick="clearMap()"
          class="row-1"
          style="border-color: #662222"
        >
          <span class="btn-label" style="color: #ff8888">ğŸ—‘ï¸ æ¸…ç©ºåœ°å›¾</span
          ><span class="btn-key">R</span>
        </button>
        <button class="row-1" id="btn-auto" onclick="toggleAutoObs()">
          <span class="btn-label"
            >âœ¨ å¨œå·¥ä¹‹åŠ›: <span id="status-text">å¼€</span></span
          ><span class="btn-key">V</span>
        </button>
      </div>

      <div class="section">
        <div class="section-header">æ¼”ç®—æ§åˆ¶ OPERATIONS</div>
        <button class="row-1" id="btn-start" onclick="startSimulation()">
          <span class="btn-label">â–¶ å¼€å§‹å…¨å›¾æ¼”ç®—</span
          ><span class="btn-key">SPACE</span>
        </button>
        <div class="row-2">
          <button onclick="replayAnimation()">
            <span class="btn-label">ğŸ”„ é‡æ’­</span
            ><span class="btn-key">ENTER</span>
          </button>
          <button onclick="stopAnimation()">
            <span class="btn-label">â¸ åœæ­¢</span>
          </button>
        </div>
        <button onclick="clearPathOnly()" style="margin-top: 10px; width: 100%">
          <span class="btn-label" style="color: #ffaaaa">ğŸ—‘ï¸ ä»…æ¸…ç©ºè·¯å¾„</span
          ><span class="btn-key">C</span>
        </button>
      </div>

      <div class="section" id="result-section">
        <div class="section-header">æ¼”ç®—ç»“æœ RESULTS (TOP 3)</div>
        <div id="result-list">
          <div
            style="
              padding: 10px;
              color: #666;
              font-size: 12px;
              text-align: center;
            "
          >
            æš‚æ— æ•°æ®<br />è¯·ç‚¹å‡»å¼€å§‹æ¼”ç®—
          </div>
        </div>
      </div>

      <div id="save-area-wrapper">
        <div class="row-2" style="margin-bottom: 5px">
          <button onclick="saveMap()" style="padding: 5px 0">
            <span class="btn-label" style="font-size: 11px">ğŸ’¾ ä¿å­˜</span>
          </button>
          <button onclick="loadMapList()" style="padding: 5px 0">
            <span class="btn-label" style="font-size: 11px">ğŸ“‚ åˆ·æ–°</span>
          </button>
        </div>
        <div id="save-area"></div>
      </div>
    </div>

    <script>
      const CONFIG = {
        gridSize: 70,
        cols: 14,
        rows: 9,
        timeLimit: 20.0,
        moveDuration: 1 / 1.3,
        turnDuration: 0.25,
        collisionRadius: 1.5,
        colors: {
          grid: "rgba(255, 255, 255, 0.03)",
          wall: "#444",
          wallTop: "#666",
          autoObs: "rgba(255, 170, 0, 0.8)",
          startBox: "rgba(0, 200, 255, 0.8)",
          banTile: "rgba(50, 20, 20, 0.5)",
          banStroke: "rgba(100, 40, 40, 0.8)",
          deploy: "#00ccff",
          bossTile: "rgba(160, 60, 160, 0.5)",
          bossStroke: "rgba(200, 80, 200, 0.8)", // BOSS é¢œè‰²
        },
      };
      const assets = {
        chenVideo: document.getElementById("chenVideo"),
        enemyImg: document.getElementById("enemyImg"),
      };
      const state = {
        grid: [],
        enemyPath: [],
        mode: "EDIT",
        tool: "wall",
        autoObsEnabled: true,
        bestResult: null,
        animStartTime: 0,
        isAnimating: false,
        rafId: null,
        lastCombo: 0,
        candidates: [],
      };
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d", { alpha: false });
      const DIRECTIONS = [
        [-1, 0],
        [0, 1],
        [1, 0],
        [0, -1],
      ];

      initGridData();
      resizeCanvas();
      setTool("wall");
      loadMapList();
      window.addEventListener("resize", resizeCanvas);

      function initGridData() {
        state.grid = Array(CONFIG.rows)
          .fill(null)
          .map(() => Array(CONFIG.cols).fill(0));
        state.enemyPath = [];
        state.bestResult = null;
        state.candidates = [];
      }
      function resizeCanvas() {
        if (window.innerWidth < 800) {
          const maxGw = Math.floor((window.innerWidth - 20) / CONFIG.cols);
          CONFIG.gridSize = Math.min(70, maxGw);
        } else {
          CONFIG.gridSize = 70;
        }
        canvas.width = CONFIG.cols * CONFIG.gridSize;
        canvas.height = CONFIG.rows * CONFIG.gridSize;
        canvas.style.width = `${canvas.width}px`;
        canvas.style.height = `${canvas.height}px`;
        render();
      }

      // --- æ ¸å¿ƒæ¸²æŸ“ ---
      function render() {
        if (!state.grid || state.grid.length === 0) return;
        const gs = CONFIG.gridSize;
        ctx.fillStyle = "#161616";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.strokeStyle = CONFIG.colors.grid;
        ctx.lineWidth = 1;
        for (let r = 0; r <= CONFIG.rows; r++) {
          ctx.moveTo(0, r * gs);
          ctx.lineTo(canvas.width, r * gs);
        }
        for (let c = 0; c <= CONFIG.cols; c++) {
          ctx.moveTo(c * gs, 0);
          ctx.lineTo(c * gs, canvas.height);
        }
        ctx.stroke();
        for (let r = 0; r < CONFIG.rows; r++) {
          for (let c = 0; c < CONFIG.cols; c++) {
            const type = state.grid[r][c];
            const x = c * gs;
            const y = r * gs;
            if (type === 1) {
              // å¢™
              ctx.fillStyle = CONFIG.colors.wall;
              ctx.fillRect(x + 2, y + 10, gs - 4, gs - 12);
              ctx.fillStyle = CONFIG.colors.wallTop;
              ctx.fillRect(x + 2, y + 2, gs - 4, 8);
            } else if (type === 2) {
              // ç¦å…¥
              ctx.fillStyle = CONFIG.colors.banTile;
              ctx.fillRect(x + 1, y + 1, gs - 2, gs - 2);
              ctx.beginPath();
              ctx.strokeStyle = CONFIG.colors.banStroke;
              ctx.lineWidth = 2;
              ctx.moveTo(x, y);
              ctx.lineTo(x + gs, y + gs);
              ctx.moveTo(x + gs, y);
              ctx.lineTo(x, y + gs);
              ctx.stroke();
              ctx.strokeRect(x + 2, y + 2, gs - 4, gs - 4);
            } else if (type === 3) {
              // BOSS (æ–°)
              ctx.fillStyle = CONFIG.colors.bossTile;
              ctx.fillRect(x + 1, y + 1, gs - 2, gs - 2);
              ctx.strokeStyle = CONFIG.colors.bossStroke;
              ctx.lineWidth = 3;
              ctx.strokeRect(x + 4, y + 4, gs - 8, gs - 8);
            }
          }
        }
        state.enemyPath.forEach((p) => {
          const x = p.c * gs;
          const y = p.r * gs;
          ctx.fillStyle = "#ff3333";
          ctx.beginPath();
          ctx.arc(x + gs / 2, y + gs / 2, 5, 0, Math.PI * 2);
          ctx.fill();
        });
        if (state.mode === "ANIM" && state.bestResult) {
          drawAnimation(gs);
        }
      }

      function drawAnimation(gs) {
        const res = state.bestResult;
        const elapsed = performance.now() - state.animStartTime;
        const simTime = elapsed / 1000;
        if (res.obs) {
          const ox = res.obs.c * gs;
          const oy = res.obs.r * gs;
          const activationTime = res.obs.t || 0;
          if (simTime >= activationTime) {
            let scale = 1;
            if (simTime - activationTime < 0.2)
              scale = (simTime - activationTime) / 0.2;
            ctx.save();
            ctx.translate(ox + gs / 2, oy + gs / 2);
            ctx.scale(scale, scale);
            ctx.fillStyle =
              activationTime > 0 ? CONFIG.colors.deploy : CONFIG.colors.autoObs;
            ctx.fillRect(-gs / 2 + 2, -gs / 2 + 2, gs - 4, gs - 4);
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            ctx.strokeRect(-gs / 2 + 2, -gs / 2 + 2, gs - 4, gs - 4);
            if (activationTime > 0) {
              ctx.fillStyle = "#fff";
              ctx.font = "bold 12px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText("é«˜å°", 0, 0);
            }
            ctx.restore();
          } else {
            ctx.strokeStyle = CONFIG.colors.deploy;
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.strokeRect(ox + 4, oy + 4, gs - 8, gs - 8);
            ctx.setLineDash([]);
            const timeLeft = (activationTime - simTime).toFixed(1);
            ctx.fillStyle = "#fff";
            ctx.font = "10px Arial";
            ctx.fillText(timeLeft + "s", ox + gs / 2 - 10, oy + gs / 2);
          }
        }
        if (res.target && assets.enemyImg.complete) {
          const tx = res.target.c * gs;
          const ty = res.target.r * gs;
          const imgSize = gs * 0.8;
          const offset = (gs - imgSize) / 2;
          ctx.drawImage(
            assets.enemyImg,
            tx + offset,
            ty + offset,
            imgSize,
            imgSize,
          );
        }
        const sx = res.shooter.c * gs;
        const sy = res.shooter.r * gs;
        ctx.strokeStyle = CONFIG.colors.startBox;
        ctx.lineWidth = 3;
        ctx.setLineDash([8, 4]);
        ctx.strokeRect(sx, sy, gs, gs);
        ctx.setLineDash([]);
        const isMobile = window.innerWidth < 800;
        if (isMobile) {
          ctx.fillStyle = "#00ccff";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("é™ˆ", sx + gs / 2, sy + gs / 2);
          ctx.textAlign = "start";
          ctx.textBaseline = "alphabetic";
        } else {
          let vRatio = 0.56;
          if (assets.chenVideo.videoWidth && assets.chenVideo.videoHeight) {
            vRatio = assets.chenVideo.videoWidth / assets.chenVideo.videoHeight;
          }
          if (assets.chenVideo.readyState >= 2) {
            const scaleFactor = 2.25;
            const renderH = gs * scaleFactor;
            const renderW = renderH * vRatio;
            const dx = sx + (gs - renderW) / 2;
            const dy = sy + gs - renderH + 25;
            ctx.drawImage(assets.chenVideo, dx, dy, renderW, renderH);
          } else {
            ctx.fillStyle = "#0cf";
            ctx.fillText("CHEN", sx + 5, sy + 20);
          }
        }
        const path = res.path;
        let currNode = path[0];
        let nextNode = path[path.length - 1];
        let validSegment = false;
        for (let i = 0; i < path.length - 1; i++) {
          if (simTime >= path[i].t && simTime < path[i + 1].t) {
            currNode = path[i];
            nextNode = path[i + 1];
            validSegment = true;
            break;
          }
        }
        if (simTime >= path[path.length - 1].t) {
          currNode = path[path.length - 1];
          nextNode = currNode;
          validSegment = true;
        }
        if (validSegment) {
          const segmentDuration = nextNode.t - currNode.t;
          const p =
            segmentDuration > 0 ? (simTime - currNode.t) / segmentDuration : 1;
          const currX = currNode.c * gs;
          const currY = currNode.r * gs;
          const nextX = nextNode.c * gs;
          const nextY = nextNode.r * gs;
          const drawX = currX + (nextX - currX) * p;
          const drawY = currY + (nextY - currY) * p;
          drawDragonQi(drawX, drawY, gs, currNode.d, simTime);
        }
        let currentCombo = 0;
        for (let i = 0; i < res.path.length; i++) {
          if (res.path[i].t <= simTime && res.path[i].hit) {
            currentCombo++;
          }
        }
        const comboPanel = document.getElementById("combo-panel");
        const comboCountDiv = document.getElementById("combo-count");
        if (comboPanel) {
          comboPanel.classList.add("active");
          if (currentCombo > state.lastCombo) {
            comboCountDiv.innerText = currentCombo;
            comboCountDiv.classList.remove("pulse-anim");
            void comboCountDiv.offsetWidth;
            comboCountDiv.classList.add("pulse-anim");
            state.lastCombo = currentCombo;
          }
        }
      }
      function drawDragonQi(x, y, gs, dir, time) {
        ctx.save();
        const cx = x + gs / 2;
        const cy = y + gs / 2;
        ctx.translate(cx, cy);
        let rot = 0;
        if (dir === 0) rot = -90;
        if (dir === 2) rot = 90;
        if (dir === 3) rot = 180;
        ctx.rotate((rot * Math.PI) / 180);
        const grad = ctx.createRadialGradient(0, 0, gs * 0.1, 0, 0, gs * 0.4);
        grad.addColorStop(0, "rgba(255, 30, 30, 1)");
        grad.addColorStop(1, "rgba(255, 0, 0, 0)");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, gs * 0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#f00";
        const snakeLen = gs * 0.6;
        const waveAmp = 5;
        ctx.moveTo(snakeLen / 2, 0);
        for (let i = 0; i < 10; i++) {
          const px = snakeLen / 2 - i * (snakeLen / 10);
          const py = Math.sin((px + time * 200) / 10) * waveAmp * (1 - i / 10);
          ctx.lineTo(px, py);
        }
        ctx.stroke();
        ctx.fillStyle = "#ff0";
        ctx.beginPath();
        ctx.arc(snakeLen / 2 - 2, -2, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // --- æ–°å¢ï¼šå¹¿åŸŸå‘½ä¸­æ£€æµ‹ (ä¿®å¤BOSSåˆ¤å®šèŒƒå›´BUG) ---
      function checkAreaHit(r, c, grid, targetPos) {
        // 1. åŸºç¡€æ£€æµ‹ï¼šæ˜¯å¦å‘½ä¸­æŒ‡å®šçš„ç›®æ ‡ç‚¹ (å°çº¢ç‚¹)
        let distTarget = Math.sqrt(
          Math.pow(r - targetPos.r, 2) + Math.pow(c - targetPos.c, 2),
        );
        if (distTarget <= CONFIG.collisionRadius) return true;

        // 2. å¹¿åŸŸæ£€æµ‹ï¼šæ‰«æå‘¨å›´åŠå¾„å†…çš„æ ¼å­ï¼Œçœ‹æœ‰æ²¡æœ‰ BOSS (Type 3)
        // ä¼˜åŒ–ï¼šåªæ‰«æ collisionRadius èŒƒå›´å†…çš„çŸ©å½¢åŒºåŸŸ
        const range = Math.ceil(CONFIG.collisionRadius);
        const rMin = Math.max(0, r - range);
        const rMax = Math.min(CONFIG.rows - 1, r + range);
        const cMin = Math.max(0, c - range);
        const cMax = Math.min(CONFIG.cols - 1, c + range);

        for (let i = rMin; i <= rMax; i++) {
          for (let j = cMin; j <= cMax; j++) {
            if (grid[i][j] === 3) {
              // å‘ç° BOSS æ ¼å­
              // è®¡ç®—å‰‘æ°”ä¸­å¿ƒåˆ°è¯¥ BOSS æ ¼å­ä¸­å¿ƒçš„è·ç¦»
              let distBoss = Math.sqrt(Math.pow(r - i, 2) + Math.pow(c - j, 2));
              if (distBoss <= CONFIG.collisionRadius) return true;
            }
          }
        }
        return false;
      }

      // --- ç®—æ³•æ ¸å¿ƒ v5.6ï¼šä¿®å¤åˆ¤å®šèŒƒå›´ä¸è½¬å‘é” ---
      function simulateSword(
        shooterR,
        shooterC,
        shooterD,
        gridSnapshot,
        targetPos,
        dynamicObs = null,
      ) {
        let r = shooterR,
          c = shooterC,
          d = shooterD;
        let hits = 0;
        let currentTime = 0;
        const path = [];
        let hasHitInLine = false;

        // åˆå§‹åˆ¤å®š
        if (checkAreaHit(r, c, gridSnapshot, targetPos)) {
          hits++;
          hasHitInLine = true;
        }
        path.push({ r, c, d, t: 0, hit: hasHitInLine, action: "start" });

        while (currentTime < CONFIG.timeLimit) {
          const dr = DIRECTIONS[d][0];
          const dc = DIRECTIONS[d][1];
          const nextR = r + dr;
          const nextC = c + dc;
          let blocked = false;

          // è¾¹ç•Œæ£€æŸ¥
          if (
            nextR < 0 ||
            nextR >= CONFIG.rows ||
            nextC < 0 ||
            nextC >= CONFIG.cols
          )
            blocked = true;
          else if (gridSnapshot[nextR][nextC] === 1) blocked = true; // 1=å¢™ï¼Œé˜»æŒ¡
          // æ³¨æ„ï¼šType 3 (BOSS) ä¸é˜»æŒ¡ï¼ŒBlocked ä¿æŒ false

          // åŠ¨æ€éšœç¢æ£€æŸ¥
          if (dynamicObs && nextR === dynamicObs.r && nextC === dynamicObs.c) {
            if (currentTime >= dynamicObs.t) blocked = true;
          }

          // è®¡ç®—å½“å‰æ˜¯å¦å‘½ä¸­ (ä½¿ç”¨æ–°å‡½æ•°æ£€æµ‹å‘¨å›´)
          let isHit = checkAreaHit(r, c, gridSnapshot, targetPos);

          if (blocked) {
            // --- è½¬å‘é€»è¾‘ ---
            let turnHit = false;

            // å¦‚æœè½¬å‘æ—¶å°±åœ¨æ•ŒäººèŒƒå›´å†…
            if (isHit) {
              hits++;
              turnHit = true;

              // ã€æ ¸å¿ƒä¿®å¤ã€‘
              // å¦‚æœè½¬å‘ç¬é—´é€ æˆäº†ä¼¤å®³ï¼Œè¿™ç®—ä½œâ€œæ–°æ–¹å‘â€çš„ç¬¬ä¸€å‡»ã€‚
              // å› æ­¤ï¼Œå¿…é¡»ç«‹å³é”å®šåç»­çš„ç›´çº¿ç§»åŠ¨ï¼Œé˜²æ­¢é‡å¤æ‰£è¡€ã€‚
              hasHitInLine = true;
            } else {
              // åªæœ‰åœ¨ç©ºåœ°è½¬å‘æ—¶ï¼Œæ‰é‡ç½®é”ï¼Œå…è®¸åç»­ç§»åŠ¨é€ æˆä¼¤å®³
              hasHitInLine = false;
            }

            currentTime += CONFIG.turnDuration;
            d = (d + 1) % 4;

            path.push({
              r,
              c,
              d,
              t: currentTime,
              hit: turnHit,
              action: "turn",
            });
          } else {
            // --- ç§»åŠ¨é€»è¾‘ ---
            currentTime += CONFIG.moveDuration;
            r = nextR;
            c = nextC;

            // ç§»åŠ¨åˆ°äº†æ–°ä½ç½®ï¼Œé‡æ–°æ£€æµ‹å‘¨å›´
            isHit = checkAreaHit(r, c, gridSnapshot, targetPos);

            let effectiveHit = false;
            // ç§»åŠ¨ä¼¤å®³å—ç›´çº¿é”é™åˆ¶ï¼Œé¿å…ç©¿è¿‡åŒä¸€ä¸ªæ ¼å­ç®—å¤šæ¬¡
            if (isHit && !hasHitInLine) {
              hits++;
              effectiveHit = true;
              hasHitInLine = true;
            }

            path.push({
              r,
              c,
              d,
              t: currentTime,
              hit: effectiveHit,
              action: "move",
            });
          }
        }
        return { hits, path };
      }

      // --- ç®—æ³•å…¥å£ ---
      function startSimulation() {
        // å¦‚æœæ²¡æœ‰çº¢ç‚¹(Enemy Path)ï¼Œä¹Ÿæ²¡æœ‰ BOSS æ ¼å­ï¼Œåˆ™æç¤º
        let hasBoss = false;
        for (let r = 0; r < CONFIG.rows; r++)
          for (let c = 0; c < CONFIG.cols; c++)
            if (state.grid[r][c] === 3) hasBoss = true;

        if (state.enemyPath.length === 0 && !hasBoss) {
          alert("è¯·å…ˆæ ‡è®°æ•Œäººè·¯å¾„ç‚¹æˆ–ç»˜åˆ¶BOSSï¼");
          return;
        }

        document.getElementById("overlay").style.display = "flex";
        state.candidates = [];

        setTimeout(() => {
          const rows = CONFIG.rows;
          const cols = CONFIG.cols;
          const addCandidate = (hits, shooter, dir, target, obs) => {
            if (hits <= 0) return;
            state.candidates.push({ hits, shooter, dir, target, obs });
          };

          // æ„é€ ç›®æ ‡åˆ—è¡¨ï¼šEnemyPath + è™šæ‹Ÿç›®æ ‡(å¦‚æœæœ‰Bossä½†æ²¡çº¢ç‚¹)
          // å…¶å® simulateSword å·²ç»æ”¯æŒ Boss æ ¼å­å‘½ä¸­ï¼ŒTargetPos ä¸»è¦ç”¨äºå¼•å¯¼â€œå‘å“ªé‡Œå°„å‡»â€çš„é€»è¾‘(å¯é€‰ä¼˜åŒ–)ï¼Œ
          // è¿™é‡Œæˆ‘ä»¬è¿˜æ˜¯ä»¥ EnemyPath ä¸ºä¸»éå†ã€‚å¦‚æœåªæœ‰ Boss æ²¡æœ‰ Pathï¼Œå¯ä»¥ä¼ªé€ ä¸€ä¸ª target åœ¨ Boss ä¸­å¿ƒã€‚
          let targets = [...state.enemyPath];
          if (targets.length === 0 && hasBoss) {
            // æ‰¾ä¸€ä¸ª BOSS æ ¼å­å½“ä¼ªç›®æ ‡ï¼Œä¿è¯å¾ªç¯èƒ½è·‘èµ·æ¥
            for (let r = 0; r < rows; r++) {
              for (let c = 0; c < cols; c++) {
                if (state.grid[r][c] === 3) {
                  targets.push({ r, c });
                  break;
                }
              }
              if (targets.length > 0) break;
            }
          }

          for (let tIdx = 0; tIdx < targets.length; tIdx++) {
            const target = targets[tIdx];
            for (let r = 0; r < rows; r++) {
              for (let c = 0; c < cols; c++) {
                // å‰ªæï¼šä¸èƒ½åœ¨å¢™(1)ã€ç¦åŒº(2)ã€BOSS(3)ä¸Šéƒ¨ç½²é™ˆ
                if (state.grid[r][c] !== 0) continue;
                if (r === target.r && c === target.c) continue;

                for (let d = 0; d < 4; d++) {
                  // 1. è£¸è·‘
                  const simBase = simulateSword(
                    r,
                    c,
                    d,
                    state.grid,
                    target,
                    null,
                  );
                  addCandidate(simBase.hits, { r, c }, d, target, null);

                  if (!state.autoObsEnabled || simBase.path.length === 0)
                    continue;

                  // 2. åŒé‡ç©·ä¸¾
                  const visitedKeys = new Set();
                  for (let i = 0; i < simBase.path.length; i++) {
                    const step = simBase.path[i];
                    const candR = step.r;
                    const candC = step.c;
                    const key = `${candR},${candC}`;

                    if (visitedKeys.has(key)) continue;
                    if (candR === target.r && candC === target.c) continue;
                    if (candR === r && candC === c) continue;
                    // ç®±å­ä¸èƒ½æ”¾åœ¨éç©ºåœ° (å«BOSSæ ¼)
                    if (state.grid[candR][candC] !== 0) continue;
                    visitedKeys.add(key);

                    const simStatic = simulateSword(
                      r,
                      c,
                      d,
                      state.grid,
                      target,
                      { r: candR, c: candC, t: 0 },
                    );
                    addCandidate(simStatic.hits, { r, c }, d, target, {
                      r: candR,
                      c: candC,
                      t: 0,
                    });

                    const deployTime = step.t + 0.1;
                    const simDyn = simulateSword(r, c, d, state.grid, target, {
                      r: candR,
                      c: candC,
                      t: deployTime,
                    });
                    addCandidate(simDyn.hits, { r, c }, d, target, {
                      r: candR,
                      c: candC,
                      t: deployTime,
                    });
                  }
                }
              }
            }
          }
          processResults();
          document.getElementById("overlay").style.display = "none";
        }, 50);
      }

      function processResults() {
        const bestStrategies = new Map();
        state.candidates.forEach((cand) => {
          let obsFingerprint = "None";
          if (cand.obs) {
            const type = cand.obs.t > 0 ? "Dyn" : "Sta";
            obsFingerprint = `${cand.obs.r},${cand.obs.c}|${type}`;
          }
          const key = `${cand.shooter.r},${cand.shooter.c}|${obsFingerprint}`;
          if (
            !bestStrategies.has(key) ||
            cand.hits > bestStrategies.get(key).hits
          ) {
            bestStrategies.set(key, cand);
          }
        });
        let uniqueList = Array.from(bestStrategies.values());
        uniqueList.sort((a, b) => b.hits - a.hits);
        const uniqueScores = [...new Set(uniqueList.map((c) => c.hits))].slice(
          0,
          3,
        );
        const finalDisplayList = uniqueList.filter((c) =>
          uniqueScores.includes(c.hits),
        );
        const listEl = document.getElementById("result-list");
        listEl.innerHTML = "";
        if (finalDisplayList.length === 0) {
          listEl.innerHTML =
            '<div style="padding:10px;text-align:center;color:#666">æ— æœ‰æ•ˆè§£</div>';
          return;
        }
        finalDisplayList.forEach((item, index) => {
          const div = document.createElement("div");
          div.className = "res-item";
          let typeTag = "";
          let obsInfo = "";
          const dirArrows = ["â¬†ï¸", "â¡ï¸", "â¬‡ï¸", "â¬…ï¸"];
          const dirIcon = dirArrows[item.dir];
          if (item.obs) {
            if (item.obs.t > 0) {
              typeTag = `<span class="res-tag tag-dynamic">åŠ¨æ€ ${item.obs.t.toFixed(1)}s</span>`;
            } else {
              typeTag = `<span class="res-tag tag-static">é™æ€</span>`;
            }
            obsInfo = ` | ğŸ“¦[${item.obs.r},${item.obs.c}]`;
          } else {
            typeTag = `<span class="res-tag" style="background:#333;color:#888">æ— éšœç¢</span>`;
          }
          div.innerHTML = `<div class="res-score">${item.hits}</div><div class="res-info"><div>é™ˆ: [${item.shooter.r}, ${item.shooter.c}] ${dirIcon} ${typeTag}</div><div style="font-size:10px; color:#555">æ–¹æ¡ˆ #${index + 1}${obsInfo}</div></div>`;
          div.onclick = () => selectResult(item, div);
          listEl.appendChild(div);
        });
        if (listEl.firstChild) listEl.firstChild.click();
      }

      function selectResult(candidate, domElement) {
        document
          .querySelectorAll(".res-item")
          .forEach((el) => el.classList.remove("active"));
        if (domElement) domElement.classList.add("active");
        const sim = simulateSword(
          candidate.shooter.r,
          candidate.shooter.c,
          candidate.dir,
          state.grid,
          candidate.target,
          candidate.obs,
        );
        state.bestResult = {
          hits: sim.hits,
          path: sim.path,
          shooter: candidate.shooter,
          dir: candidate.dir,
          target: candidate.target,
          obs: candidate.obs,
        };
        replayAnimation();
      }

      function animLoop() {
        if (!state.isAnimating) return;
        render();
        state.rafId = requestAnimationFrame(animLoop);
      }
      function stopAnimation() {
        state.isAnimating = false;
        cancelAnimationFrame(state.rafId);
        state.mode = "EDIT";
        render();
        document.getElementById("combo-panel").classList.remove("active");
      }
      function replayAnimation() {
        if (!state.bestResult) return;
        state.mode = "ANIM";
        state.animStartTime = performance.now();
        state.isAnimating = true;
        state.lastCombo = -1;
        document.getElementById("combo-count").innerText = "0";
        animLoop();
      }

      function setTool(t) {
        state.tool = t;
        stopAnimation();
        document
          .querySelectorAll("button")
          .forEach((b) => b.classList.remove("active"));
        if (t === "wall")
          document.getElementById("btn-wall").classList.add("active");
        if (t === "ban")
          document.getElementById("btn-ban").classList.add("active");
        if (t === "boss")
          document.getElementById("btn-boss").classList.add("active");
        if (t === "path")
          document.getElementById("btn-path").classList.add("active");
      }
      function toggleAutoObs() {
        state.autoObsEnabled = !state.autoObsEnabled;
        const txt = document.getElementById("status-text");
        txt.innerText = state.autoObsEnabled ? "å¼€" : "å…³";
        txt.style.color = state.autoObsEnabled ? CONFIG.colors.autoObs : "#888";
        const btn = document.getElementById("btn-auto");
        if (state.autoObsEnabled) btn.classList.add("active");
        else btn.classList.remove("active");
      }
      function clearMap() {
        initGridData();
        render();
      }
      function clearPathOnly() {
        state.enemyPath = [];
        render();
      }

      function handleInput(x, y) {
        const c = Math.floor(x / CONFIG.gridSize);
        const r = Math.floor(y / CONFIG.gridSize);
        if (r < 0 || r >= CONFIG.rows || c < 0 || c >= CONFIG.cols) return;

        // 0:ç©º, 1:å¢™, 2:ç¦, 3:BOSS
        if (state.tool === "wall") {
          state.grid[r][c] = state.grid[r][c] === 1 ? 0 : 1;
        } else if (state.tool === "ban") {
          state.grid[r][c] = state.grid[r][c] === 2 ? 0 : 2;
        } else if (state.tool === "boss") {
          state.grid[r][c] = state.grid[r][c] === 3 ? 0 : 3;
        } else if (state.tool === "path") {
          const exists = state.enemyPath.find((p) => p.r === r && p.c === c);
          if (!exists) state.enemyPath.push({ r, c });
          else
            state.enemyPath = state.enemyPath.filter(
              (p) => p.r !== r || p.c !== c,
            );
        }
        render();
      }

      canvas.addEventListener("mousedown", (e) => {
        if (!state.grid || state.mode === "ANIM") return;
        const rect = canvas.getBoundingClientRect();
        handleInput(e.clientX - rect.left, e.clientY - rect.top);
      });
      canvas.addEventListener(
        "touchstart",
        (e) => {
          if (!state.grid || state.mode === "ANIM") return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const touch = e.touches[0];
          handleInput(touch.clientX - rect.left, touch.clientY - rect.top);
        },
        { passive: false },
      );

      document.addEventListener("keydown", (e) => {
        if (e.code === "KeyW") setTool("wall");
        if (e.code === "KeyX") setTool("ban");
        if (e.code === "KeyB") setTool("boss");
        if (e.code === "KeyF") setTool("path");
        if (e.code === "KeyC") clearPathOnly();
        if (e.code === "KeyR") clearMap();
        if (e.code === "KeyV") toggleAutoObs();
        if (e.code === "Space") {
          e.preventDefault();
          startSimulation();
        }
        if (e.code === "Enter") replayAnimation();
      });

      function saveMap() {
        const name = prompt("å­˜æ¡£åç§°:", "æ–°çš„æ–¹æ¡ˆ");
        if (!name) return;
        const data = { grid: state.grid, path: state.enemyPath };
        const saves = JSON.parse(localStorage.getItem("terra_saves") || "{}");
        saves[name] = data;
        localStorage.setItem("terra_saves", JSON.stringify(saves));
        loadMapList();
      }
      function loadMapList() {
        const div = document.getElementById("save-area");
        div.innerHTML = "";
        const saves = JSON.parse(localStorage.getItem("terra_saves") || "{}");
        Object.keys(saves).forEach((name) => {
          const el = document.createElement("div");
          el.className = "save-item";
          el.innerHTML = `<span>${name}</span> <span class="del-save" onclick="delSave(event, '${name}')">Ã—</span>`;
          el.onclick = (e) => {
            if (!e.target.classList.contains("del-save")) {
              state.grid = JSON.parse(JSON.stringify(saves[name].grid));
              state.enemyPath = JSON.parse(JSON.stringify(saves[name].path));
              render();
            }
          };
          div.appendChild(el);
        });
      }
      window.delSave = function (e, name) {
        e.stopPropagation();
        const saves = JSON.parse(localStorage.getItem("terra_saves") || "{}");
        delete saves[name];
        localStorage.setItem("terra_saves", JSON.stringify(saves));
        loadMapList();
      };
      assets.chenVideo.play().catch(() => console.log("ç­‰å¾…äº¤äº’æ’­æ”¾"));
    </script>
  </body>
</html>
